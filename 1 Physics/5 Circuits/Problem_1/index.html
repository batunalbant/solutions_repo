<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="introduction">Introduction</h2>
<p>Understanding and analyzing electrical circuits is a fundamental aspect of electrical engineering and physics. One of the essential tasks in circuit analysis is determining the equivalent resistance between two points. Traditional methods rely on step-by-step application of series and parallel resistor combinations, which can become impractical for large and complex circuits. The need for a more systematic and scalable approach arises in applications such as circuit simulation, network analysis, and embedded system design.</p>
<p>Graph theory provides an alternative and efficient approach by representing the circuit as a weighted graph, where:</p>
<p><strong>Nodes</strong> correspond to junctions.</p>
<p><strong>Edges</strong> correspond to resistors with resistance values as weights.</p>
<p>By systematically simplifying this representation using graph algorithms, we can compute the equivalent resistance efficiently. This approach is particularly useful in modern circuit analysis tools, simulation software, and optimization techniques used in electronic circuit design. It also provides an automated way to handle complex networks, making the process faster and less prone to human errors.</p>
<h2 id="motivation">Motivation</h2>
<p>Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. Traditional methods involve iteratively applying series and parallel resistor rules, which become cumbersome for complex circuits. Graph theory provides a structured and algorithmic alternative, allowing us to model circuits as weighted graphs where:</p>
<p><strong>Nodes</strong> represent circuit junctions.</p>
<p><strong>Edges</strong> represent resistors, weighted by resistance values.</p>
<p>By employing graph reduction techniques, we can systematically simplify even intricate networks, leading to efficient circuit analysis methods used in modern applications like circuit simulation software, optimization problems, and network design. This method also integrates well with software-based solutions, allowing for real-time modifications and enhancements in circuit analysis.</p>
<h2 id="theoretical-background">Theoretical Background</h2>
<h3 id="graph-representation-of-electrical-circuits">Graph Representation of Electrical Circuits</h3>
<p>An electrical circuit can be represented as a graph:
<strong>Vertices (V):</strong> Represent junctions where resistors connect.</p>
<p><strong>Edges (E):</strong> Represent resistors, with edge weights corresponding to resistance values.</p>
<p><strong>Adjacency Matrix or List:</strong> Used to store the graph structure, where each row represents a node and each column represents a connection to another node with a specific resistance value.</p>
<h3 id="series-and-parallel-resistance-in-graphs">Series and Parallel Resistance in Graphs</h3>
<p><strong>Series Connection:</strong>
   - Resistors in series have the same current flowing through them.</p>
<ul>
<li>
<p>The total voltage across them is the sum of the individual voltages:</p>
<p>$$
 V_{eq} = V_1 + V_2 + ... + V_n
 $$</p>
</li>
<li>
<p>Using Ohm’s Law (<span class="arithmatex">\( V = IR \)</span>):</p>
<p>$$
 I R_{eq} = I R_1 + I R_2 + ... + I R_n
 $$</p>
</li>
<li>
<p>Canceling the common current <span class="arithmatex">\( I \)</span>:</p>
<p>$$
 R_{eq} = R_1 + R_2 + ... + R_n
 $$</p>
</li>
<li>
<p>Graphically, this corresponds to <strong>contracting</strong> a path of connected edges into a single edge, thus reducing the complexity of the graph.</p>
</li>
</ul>
<p><strong>Parallel Connection:</strong>
   - Resistors in parallel share the same voltage.</p>
<ul>
<li>
<p>The total current is the sum of the individual currents:</p>
<p>$$
 I_{eq} = I_1 + I_2 + ... + I_n
 $$</p>
</li>
<li>
<p>Using Ohm’s Law:</p>
<p>$$
 \frac{V}{R_{eq}} = \frac{V}{R_1} + \frac{V}{R_2} + ... + \frac{V}{R_n}
 $$</p>
</li>
<li>
<p>Canceling the common voltage <span class="arithmatex">\( V \)</span>:</p>
<p>$$
 \frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n}
 $$</p>
</li>
<li>
<p>Graphically, this corresponds to <strong>merging</strong> multiple edges between two nodes into a single edge with a new weight.</p>
</li>
<li>
<p>This merging reduces the computational complexity when analyzing circuits with multiple interconnected resistors.</p>
</li>
</ul>
<h3 id="extended-formulas-for-complex-cases">Extended Formulas for Complex Cases</h3>
<p>For circuits involving mixed configurations of series and parallel resistances, the equivalent resistance must be determined iteratively. If a circuit consists of nested parallel and series resistances, the calculation follows a hierarchical approach:</p>
<ul>
<li>
<p>Identify the <strong>innermost</strong> parallel or series components.</p>
</li>
<li>
<p>Compute their equivalent resistance.</p>
</li>
<li>
<p>Replace these components with their equivalent resistance and repeat the process.</p>
</li>
<li>
<p>Continue until only one resistance remains.</p>
</li>
</ul>
<p>For example, if a circuit consists of three resistors <span class="arithmatex">\( R_1, R_2, R_3 \)</span> arranged in a mixed configuration:</p>
<ul>
<li><span class="arithmatex">\( R_1 \)</span> and <span class="arithmatex">\( R_2 \)</span> in parallel:</li>
</ul>
<p>$$
  \frac{1}{R_{12}} = \frac{1}{R_1} + \frac{1}{R_2}
  $$</p>
<ul>
<li>Then, <span class="arithmatex">\( R_{12} \)</span> is in series with <span class="arithmatex">\( R_3 \)</span>:</li>
</ul>
<p>$$
  R_{eq} = R_{12} + R_3
  $$</p>
<ul>
<li>If an additional resistor <span class="arithmatex">\( R_4 \)</span> is in parallel with <span class="arithmatex">\( R_{eq} \)</span>, we apply the parallel formula again:</li>
</ul>
<p>$$
  \frac{1}{R_{final}} = \frac{1}{R_{eq}} + \frac{1}{R_4}
  $$</p>
<p>Using advanced mathematical techniques such as <strong>matrix representation of circuits</strong> and <strong>Laplace transformations</strong>, we can generalize the problem for complex networks. The impedance matrix <span class="arithmatex">\( Z \)</span> of the network can be derived using Kirchhoff’s laws and then reduced using determinant-based transformations.</p>
<h2 id="algorithmic-approach">Algorithmic Approach</h2>
<p>To find the equivalent resistance between two nodes:</p>
<p><strong>Construct the Graph</strong>: Parse circuit components into a graph data structure.</p>
<p><strong>Identify Series and Parallel Components</strong>: Use graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS).</p>
<p><strong>Iteratively Reduce the Graph</strong>:</p>
<ul>
<li>
<p>Replace series connections with their equivalent resistance.</p>
</li>
<li>
<p>Merge parallel connections into a single equivalent resistor.</p>
</li>
</ul>
<p><strong>Repeat Until Simplification is Complete</strong>: Continue reducing until only two nodes remain (input and output terminals).</p>
<p><strong>Output the Equivalent Resistance</strong>: The final edge weight represents the total equivalent resistance.</p>
<hr/>
<h2 id="algorithm-implementation">Algorithm Implementation</h2>
<h3 id="pseudocode-equivalent-resistance-calculation-using-graph-theory">Pseudocode: Equivalent Resistance Calculation Using Graph Theory</h3>
<details>
<summary>Pseudocode </summary>
<pre><code class="language-python">
1. INPUT &amp; INITIALIZATION
    INPUT: 
        - A graph G representing the circuit.
        - Nodes N = {n1, n2, n3, ...} representing junctions in the circuit.
        - Edges E = {(n1, n2, R), (n2, n3, R), ...} where each edge is a tuple:
            (Start_Node, End_Node, Resistance)
        - Define INPUT_NODE and OUTPUT_NODE representing the start and end points of the circuit.

    INITIALIZE:
        - Create a Graph G with NetworkX or similar library.
        - Mark INPUT_NODE and OUTPUT_NODE in G.
        - Visualize the initial graph (G) for reference.

2. DEFINE HELPER FUNCTIONS

    FUNCTION: Detect_Series_Connection(G)
        FOR each Node N in G:
            IF Node N has exactly TWO connections (degree = 2) AND NOT (N is INPUT_NODE or OUTPUT_NODE):
                Identify the two edges: (N, A, R1) and (N, B, R2)
                COMPUTE: Combined Resistance R = R1 + R2
                REPLACE edges (N, A) and (N, B) with a single edge (A, B, R)
                REMOVE Node N from G
                RETURN Updated Graph G

    FUNCTION: Detect_Parallel_Connection(G)
        FOR each pair of Nodes (A, B) in G:
            IF Multiple edges exist between A and B (Parallel Connection):
                LET R1, R2, ... Rn be the resistances of these edges
                COMPUTE: Combined Resistance R = 1 / (1/R1 + 1/R2 + ... + 1/Rn)
                REMOVE all edges between A and B
                ADD new edge (A, B, R)
                RETURN Updated Graph G

3. ALGORITHM (Main Procedure)
    WHILE (Number of Edges in G &gt; 1):
        STEP 1: Display Current Graph G for Visualization

        STEP 2: Apply Detect_Series_Connection(G)
            - Identify and simplify all series connections in G.
            - Visualize the updated graph after this step.

        STEP 3: Apply Detect_Parallel_Connection(G)
            - Identify and simplify all parallel connections in G.
            - Visualize the updated graph after this step.

        STEP 4: If no changes were made by Detect_Series_Connection or Detect_Parallel_Connection:
            - Terminate the loop as the graph cannot be further simplified.

        STEP 5: Repeat the process until G contains only a single edge between INPUT_NODE and OUTPUT_NODE.

4. OUTPUT &amp; VISUALIZATION
    IF (Single Edge exists between INPUT_NODE and OUTPUT_NODE):
        - OUTPUT: Equivalent Resistance of the Circuit is the weight of that single edge.
    ELSE:
        - ERROR: Graph could not be fully reduced. Check for topological errors.

    DISPLAY:
        - Show the original graph and all intermediate steps as the graph is simplified.

5. GRAPH VALIDATION (Optional Step)
    FUNCTION: Validate_Graph_Topology(G)
        IF (INPUT_NODE or OUTPUT_NODE is missing):
            RETURN Error: "Starting or Ending node is missing."

        IF (INPUT_NODE is isolated or OUTPUT_NODE is isolated):
            RETURN Error: "Invalid topology. Ensure connections are properly established."

        RETURN "Graph Topology is Valid."

</code></pre>
</details>
<h3 id="implementation-plan">Implementation Plan</h3>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

class CircuitGraph:
    def __init__(self):
        self.G = nx.Graph()  # Create a new graph
        self.input_node = None  # Define the input node
        self.output_node = None  # Define the output node

    def add_resistor(self, node1, node2, resistance):
        """Adds a resistor (edge) between two nodes with a given resistance."""
        self.G.add_edge(node1, node2, resistance=resistance)

    def set_input_output(self, input_node, output_node):
        """Sets the input and output nodes."""
        self.input_node = input_node
        self.output_node = output_node

    def visualize(self, title="Circuit Graph", path=None):
        """Visualizes the current state of the circuit graph."""
        pos = nx.spring_layout(self.G, seed=42)
        labels = nx.get_edge_attributes(self.G, 'resistance')

        plt.figure(figsize=(8, 6))
        nx.draw(self.G, pos, with_labels=True, node_size=700, node_color='skyblue', font_size=12, font_color='black')
        nx.draw_networkx_edge_labels(self.G, pos, edge_labels=labels)

        # Highlight the input and output nodes
        nx.draw_networkx_nodes(self.G, pos, nodelist=[self.input_node], node_color='green', label='Input Node')
        nx.draw_networkx_nodes(self.G, pos, nodelist=[self.output_node], node_color='red', label='Output Node')

        # Highlight the path from input to output if provided
        if path:
            edge_list = [(path[i], path[i+1]) for i in range(len(path)-1)]
            nx.draw_networkx_edges(self.G, pos, edgelist=edge_list, edge_color='orange', width=2)

        plt.title(title)
        plt.show()

    def find_path(self):
        """Finds a path from input node to output node."""
        if self.input_node and self.output_node:
            try:
                # Find the shortest path between input and output nodes
                path = nx.shortest_path(self.G, source=self.input_node, target=self.output_node)
                return path
            except nx.NetworkXNoPath:
                print("No path found between input and output nodes.")
                return None
        else:
            print("Input or Output node is not defined.")
            return None

</code></pre>
</details>
<h1 id="explanation-of-circuitgraph-class">Explanation of CircuitGraph Class</h1>
<p>This code defines a Python Class (<code>CircuitGraph</code>) that represents an electrical circuit as a graph. The purpose of this code is to:</p>
<ul>
<li>
<p>Model an electrical circuit using the <code>NetworkX</code> library where nodes represent junctions and edges represent resistors.</p>
</li>
<li>
<p>Add resistors between nodes by creating edges with resistance attributes.</p>
</li>
<li>
<p>Define the starting and ending points of the circuit (Input and Output nodes).</p>
</li>
<li>
<p>Visualize the graph using <code>Matplotlib</code>, displaying nodes, edges, and paths between input and output nodes.</p>
</li>
</ul>
<h2 id="why-this-code-is-written">Why This Code Is Written?</h2>
<p>The purpose of writing this code is to create a system that can:</p>
<ul>
<li>
<p>Model a complex electrical circuit as a graph.</p>
</li>
<li>
<p>Identify connections between nodes and simplify the circuit using graph theory techniques.</p>
</li>
<li>
<p>Visualize the entire graph and the identified path between input and output nodes, making the process of simplification clearer.</p>
</li>
</ul>
<h2 id="components-of-this-code">Components of This Code</h2>
<ul>
<li>
<p><code>__init__()</code> Method: Initializes an empty graph and placeholders for input and output nodes.</p>
</li>
<li>
<p><code>add_resistor()</code> Method: Adds resistors as edges with resistance values between nodes.</p>
</li>
<li>
<p><code>set_input_output()</code> Method: Sets the starting and ending points of the circuit.</p>
</li>
<li>
<p><code>visualize()</code> Method: Displays the graph, marking the input and output nodes and optionally showing the path between them.</p>
</li>
<li>
<p><code>find_path()</code> Method: Finds the shortest path from the input node to the output node using NetworkX's shortest path function.</p>
</li>
</ul>
<p>This code is the foundation for building the circuit graph. Now, we will focus on finding and simplifying series and parallel connections using</p>
<hr/>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python"># Create a new circuit graph
circuit = CircuitGraph()

# Add resistors
circuit.add_resistor('A', 'B', 10)
circuit.add_resistor('B', 'C', 20)
circuit.add_resistor('C', 'D', 30)
circuit.add_resistor('D', 'A', 8)
circuit.add_resistor('A', 'C', 15)

# Set the input and output nodes
circuit.set_input_output('A', 'D')

# Find the path from input to output
path = circuit.find_path()

# Visualize the circuit graph with highlighted path
circuit.visualize("Circuit Graph with Path", path=path)

</code></pre>
</details>
<p><img alt="alt text" src="../image-10.png"/></p>
<h1 id="explanation-of-circuitgraph-usage">Explanation of CircuitGraph Usage</h1>
<p>This code uses the <code>CircuitGraph</code> class to create a graphical representation of an electrical circuit. It demonstrates how to:</p>
<ul>
<li>Initialize a new graph.</li>
<li>Add resistors between nodes to form connections.</li>
<li>Define the input and output nodes.</li>
<li>Visualize the graph and highlight the path from input to output.</li>
</ul>
<hr/>
<h2 id="what-does-the-graph-show">What Does the Graph Show?</h2>
<p><strong>Nodes (A, B, C, D):</strong> </p>
<ul>
<li>
<p>These are the points where the connections (resistors) meet.</p>
</li>
<li>
<p>In a real circuit, nodes are junctions where wires or components connect.  </p>
</li>
<li>
<p>Each node is represented as a circle with a label.</p>
</li>
</ul>
<p><strong>Edges (Connections Between Nodes):</strong> </p>
<ul>
<li>
<p>The lines connecting the nodes are called edges. </p>
</li>
<li>
<p>Each edge represents a <strong>resistor</strong> with a specific resistance value (in ohms).  </p>
</li>
<li>
<p>The resistance values are labeled on the edges. </p>
</li>
</ul>
<p><strong>Input and Output Nodes (Green and Red):</strong> </p>
<ul>
<li>
<p>The <strong>Green Node (A)</strong> is the <strong>Input Node</strong>, which is where the current starts.  </p>
</li>
<li>
<p>The <strong>Red Node (D)</strong> is the <strong>Output Node</strong>, which is where the current exits the circuit.  </p>
</li>
<li>
<p>The <code>set_input_output()</code> function is used to define these nodes.  </p>
</li>
</ul>
<p><strong>Orange Path (Highlighted Connection):</strong> </p>
<ul>
<li>
<p>The orange line represents the <strong>shortest path between the Input Node (A) and the Output Node (D)</strong>. </p>
</li>
<li>
<p>It is calculated using NetworkX’s <code>shortest_path()</code> function.  </p>
</li>
<li>
<p>The shortest path only indicates the most direct connection, not necessarily the correct calculation of the overall resistance.  </p>
</li>
</ul>
<p><strong>Resistance Values (Numbers on Edges):</strong> </p>
<ul>
<li>
<p>The numbers (e.g., 10, 20, 30, 8, 15) represent the resistance values in ohms.  </p>
</li>
<li>
<p>Each resistance is assigned when creating an edge using the <code>add_resistor()</code> function.  </p>
</li>
<li>
<p>Example: <code>circuit.add_resistor('A', 'B', 10)</code> means there is a resistor of 10 ohms between nodes A and B.</p>
</li>
</ul>
<hr/>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

class CircuitGraph:
    def __init__(self):
        self.G = nx.Graph()
        self.input_node = None
        self.output_node = None

    def add_resistor(self, node1, node2, resistance):
        self.G.add_edge(node1, node2, resistance=resistance)

    def set_input_output(self, input_node, output_node):
        self.input_node = input_node
        self.output_node = output_node

    def find_path(self):
        if self.input_node and self.output_node:
            try:
                path = nx.shortest_path(self.G, source=self.input_node, target=self.output_node)
                return path
            except nx.NetworkXNoPath:
                return None

    def visualize(self, title="Circuit Graph", path=None):
        pos = nx.spring_layout(self.G, seed=42)
        labels = nx.get_edge_attributes(self.G, 'resistance')

        plt.figure(figsize=(8, 6))
        nx.draw(self.G, pos, with_labels=True, node_size=700, node_color='skyblue', font_size=12, font_color='black')
        nx.draw_networkx_edge_labels(self.G, pos, edge_labels=labels)

        nx.draw_networkx_nodes(self.G, pos, nodelist=[self.input_node], node_color='green')
        nx.draw_networkx_nodes(self.G, pos, nodelist=[self.output_node], node_color='red')

        if path:
            edge_list = [(path[i], path[i+1]) for i in range(len(path)-1)]
            nx.draw_networkx_edges(self.G, pos, edgelist=edge_list, edge_color='orange', width=2)

        plt.title(title)
        plt.show()

    def simplify_series(self):
        nodes_to_remove = []

        for node in list(self.G.nodes):
            if node not in [self.input_node, self.output_node] and self.G.degree(node) == 2:
                neighbors = list(self.G.neighbors(node))

                if len(neighbors) == 2:
                    R1 = self.G[node][neighbors[0]]['resistance']
                    R2 = self.G[node][neighbors[1]]['resistance']
                    total_resistance = R1 + R2  # Series formula: R_eq = R1 + R2

                    self.G.add_edge(neighbors[0], neighbors[1], resistance=total_resistance)
                    nodes_to_remove.append(node)

        self.G.remove_nodes_from(nodes_to_remove)
        self.visualize("After Series Simplification")

    def simplify_parallel(self):
        edges_to_remove = []
        combined_edges = {}

        for u, v, data in self.G.edges(data=True):
            if (u, v) not in combined_edges:
                combined_edges[(u, v)] = [data['resistance']]
            else:
                combined_edges[(u, v)].append(data['resistance'])

        for (u, v), resistances in combined_edges.items():
            if len(resistances) &gt; 1:
                total_resistance = 1 / sum(1 / r for r in resistances)  # Parallel formula: 1/R_eq = 1/R1 + 1/R2 + ...
                self.G[u][v]['resistance'] = total_resistance

        self.visualize("After Parallel Simplification")

    def simplify_circuit(self):
        """Fully simplifies the circuit by repeatedly applying series and parallel simplifications."""
        changed = True

        while changed:
            changed = False

            # Apply series simplification
            initial_node_count = len(self.G.nodes)
            self.simplify_series()
            if len(self.G.nodes) &lt; initial_node_count:
                changed = True

            # Apply parallel simplification
            initial_edge_count = len(self.G.edges)
            self.simplify_parallel()
            if len(self.G.edges) &lt; initial_edge_count:
                changed = True

            # Visualize the graph at each step
            self.visualize("Simplifying Circuit")


</code></pre>
</details>
<h1 id="explanation-of-circuitgraph-class-mathematical-physical-context">Explanation of CircuitGraph Class (Mathematical &amp; Physical Context)</h1>
<h3 id="purpose-of-the-code"><strong>Purpose of the Code:</strong></h3>
<p>The purpose of this code is to model an electrical circuit using Graph Theory. The electrical circuit is represented as a graph where:</p>
<ul>
<li>
<p><strong>Nodes:</strong> Represent points of connection (junctions) in the circuit. For example, junctions where resistors meet.</p>
</li>
<li>
<p><strong>Edges:</strong> Represent resistors between nodes with specific resistance values (in Ohms).</p>
</li>
<li>
<p><strong>Input Node:</strong> The starting point of the circuit where the current enters.</p>
</li>
<li>
<p><strong>Output Node:</strong> The ending point of the circuit where the current exits.</p>
</li>
</ul>
<h3 id="mathematical-physical-representation"><strong>Mathematical &amp; Physical Representation:</strong></h3>
<ul>
<li>
<p>The circuit is treated as an <strong>undirected graph</strong> <span class="arithmatex">\( G = (V, E) \)</span> where:</p>
</li>
<li>
<p><span class="arithmatex">\( V \)</span> is the set of vertices (nodes).</p>
</li>
<li>
<p><span class="arithmatex">\( E \)</span> is the set of edges (resistors) between nodes.</p>
</li>
<li>
<p>The resistance between two nodes <span class="arithmatex">\( A \)</span> and <span class="arithmatex">\( B \)</span> is represented by an edge <span class="arithmatex">\( (A, B) \)</span> with an attribute <code>resistance</code>.</p>
</li>
</ul>
<h3 id="series-and-parallel-connections-fundamental-physics-laws"><strong>Series and Parallel Connections (Fundamental Physics Laws):</strong></h3>
<ul>
<li>
<p><strong>Series Connection:</strong> When two or more resistors are connected end-to-end between two nodes.</p>
</li>
<li>
<p>The total resistance <span class="arithmatex">\( R_{eq} \)</span> is the sum of individual resistances:</p>
<div class="arithmatex">\[
R_{eq} = R_1 + R_2 + \ldots + R_n
\]</div>
</li>
<li>
<p><strong>Parallel Connection:</strong> When two or more resistors are connected between the same two nodes.</p>
</li>
<li>
<p>The total resistance <span class="arithmatex">\( R_{eq} \)</span> is calculated using the reciprocal sum formula:</p>
<div class="arithmatex">\[
\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + \ldots + \frac{1}{R_n}
\]</div>
</li>
</ul>
<hr/>
<h1 id="explanation-of-simplification-functions-series-parallel-connections">Explanation of Simplification Functions (Series &amp; Parallel Connections)</h1>
<h2 id="mathematical-physical-context"><strong>Mathematical &amp; Physical Context:</strong></h2>
<p>The simplification process is based on the fundamental physics rules of series and parallel resistances.</p>
<hr/>
<h3 id="series-connections-physics-law"><strong>Series Connections (Physics Law):</strong></h3>
<ul>
<li>
<p>When resistors are connected in a sequence, the total resistance is simply the sum of all resistances in the path.</p>
</li>
<li>
<p>The total resistance for a series connection between two points is calculated as:</p>
</li>
</ul>
<p>$$
  R_{eq} = R_1 + R_2 + \ldots + R_n
  $$</p>
<ul>
<li>This is a direct application of <strong>Ohm’s Law</strong> and <strong>Kirchhoff’s Voltage Law (KVL)</strong> which states that the sum of potential differences around any closed loop must be zero.</li>
</ul>
<hr/>
<h3 id="parallel-connections-physics-law"><strong>Parallel Connections (Physics Law):</strong></h3>
<ul>
<li>When resistors are connected across the same two points, the total resistance is calculated using the reciprocal sum formula:</li>
</ul>
<p>$$
  \frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + \ldots + \frac{1}{R_n}
  $$</p>
<ul>
<li>This relation comes from <strong>Kirchhoff’s Current Law (KCL)</strong> which states that the total current entering a junction is equal to the total current leaving it.</li>
</ul>
<hr/>
<h2 id="implementation-of-simplification-functions"><strong>Implementation of Simplification Functions:</strong></h2>
<p>The code adds two functions to the <code>CircuitGraph</code> class:</p>
<hr/>
<h3 id="detecting-and-simplifying-series-connections">** Detecting and Simplifying Series Connections:**</h3>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">def simplify_series(self):
    nodes_to_remove = []

    for node in list(self.G.nodes):
        if node not in [self.input_node, self.output_node] and self.G.degree(node) == 2:
            neighbors = list(self.G.neighbors(node))

            if len(neighbors) == 2:
                R1 = self.G[node][neighbors[0]]['resistance']
                R2 = self.G[node][neighbors[1]]['resistance']
                total_resistance = R1 + R2  # Series formula: R_eq = R1 + R2

                self.G.add_edge(neighbors[0], neighbors[1], resistance=total_resistance)
                nodes_to_remove.append(node)

    self.G.remove_nodes_from(nodes_to_remove)
    self.visualize("After Series Simplification")

</code></pre>
</details>
<h1 id="explanation-of-iterative-simplification-process">Explanation of Iterative Simplification Process</h1>
<h3 id="purpose-of-the-code_1"><strong>Purpose of the Code:</strong></h3>
<p>This code extends the <code>CircuitGraph</code> class to apply the series and parallel simplification functions repeatedly until the entire circuit is reduced to a single equivalent resistance between the input and output nodes.</p>
<hr/>
<h2 id="mathematical-physical-context_1"><strong>Mathematical &amp; Physical Context:</strong></h2>
<p>The iterative simplification process relies on continuously applying the following principles until the graph is fully simplified:</p>
<h3 id="series-simplification-ohms-law"><strong>Series Simplification (Ohm’s Law):</strong></h3>
<div class="arithmatex">\[
R_{eq} = R_1 + R_2 + \ldots + R_n
\]</div>
<h3 id="parallel-simplification-kirchhoffs-laws"><strong>Parallel Simplification (Kirchhoff’s Laws):</strong></h3>
<div class="arithmatex">\[
\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + \ldots + \frac{1}{R_n}
\]</div>
<hr/>
<h2 id="implementation-of-the-iterative-process"><strong>Implementation of the Iterative Process:</strong></h2>
<p>The following function is added to the <code>CircuitGraph</code> class:</p>
<hr/>
<h3 id="complete-simplification-process"><strong>Complete Simplification Process:</strong></h3>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">def simplify_circuit(self):
    """Fully simplifies the circuit by repeatedly applying series and parallel simplifications."""
    changed = True

    while changed:
        changed = False

        # Apply series simplification
        initial_node_count = len(self.G.nodes)
        self.simplify_series()
        if len(self.G.nodes) &lt; initial_node_count:
            changed = True

        # Apply parallel simplification
        initial_edge_count = len(self.G.edges)
        self.simplify_parallel()
        if len(self.G.edges) &lt; initial_edge_count:
            changed = True

        # Visualize the graph at each step
        self.visualize("Simplifying Circuit")
</code></pre>
</details>
<p><img alt="alt text" src="../image-12.png"/></p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
