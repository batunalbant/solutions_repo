<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="introduction">Introduction</h2>
<p>Understanding and analyzing electrical circuits is a fundamental aspect of electrical engineering and physics. One of the essential tasks in circuit analysis is determining the equivalent resistance between two points. Traditional methods rely on step-by-step application of series and parallel resistor combinations, which can become impractical for large and complex circuits. The need for a more systematic and scalable approach arises in applications such as circuit simulation, network analysis, and embedded system design.</p>
<p>Graph theory provides an alternative and efficient approach by representing the circuit as a weighted graph, where:</p>
<p><strong>Nodes</strong> correspond to junctions.</p>
<p><strong>Edges</strong> correspond to resistors with resistance values as weights.</p>
<p>By systematically simplifying this representation using graph algorithms, we can compute the equivalent resistance efficiently. This approach is particularly useful in modern circuit analysis tools, simulation software, and optimization techniques used in electronic circuit design. It also provides an automated way to handle complex networks, making the process faster and less prone to human errors.</p>
<h2 id="motivation">Motivation</h2>
<p>Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. Traditional methods involve iteratively applying series and parallel resistor rules, which become cumbersome for complex circuits. Graph theory provides a structured and algorithmic alternative, allowing us to model circuits as weighted graphs where:</p>
<p><strong>Nodes</strong> represent circuit junctions.</p>
<p><strong>Edges</strong> represent resistors, weighted by resistance values.</p>
<p>By employing graph reduction techniques, we can systematically simplify even intricate networks, leading to efficient circuit analysis methods used in modern applications like circuit simulation software, optimization problems, and network design. This method also integrates well with software-based solutions, allowing for real-time modifications and enhancements in circuit analysis.</p>
<h2 id="theoretical-background">Theoretical Background</h2>
<h3 id="graph-representation-of-electrical-circuits">Graph Representation of Electrical Circuits</h3>
<p>An electrical circuit can be represented as a graph:
<strong>Vertices (V):</strong> Represent junctions where resistors connect.</p>
<p><strong>Edges (E):</strong> Represent resistors, with edge weights corresponding to resistance values.</p>
<p><strong>Adjacency Matrix or List:</strong> Used to store the graph structure, where each row represents a node and each column represents a connection to another node with a specific resistance value.</p>
<h3 id="series-and-parallel-resistance-in-graphs">Series and Parallel Resistance in Graphs</h3>
<p><strong>Series Connection:</strong>
   - Resistors in series have the same current flowing through them.</p>
<ul>
<li>
<p>The total voltage across them is the sum of the individual voltages:</p>
<p>$$
 V_{eq} = V_1 + V_2 + ... + V_n
 $$</p>
</li>
<li>
<p>Using Ohm’s Law (<span class="arithmatex">\( V = IR \)</span>):</p>
<p>$$
 I R_{eq} = I R_1 + I R_2 + ... + I R_n
 $$</p>
</li>
<li>
<p>Canceling the common current <span class="arithmatex">\( I \)</span>:</p>
<p>$$
 R_{eq} = R_1 + R_2 + ... + R_n
 $$</p>
</li>
<li>
<p>Graphically, this corresponds to <strong>contracting</strong> a path of connected edges into a single edge, thus reducing the complexity of the graph.</p>
</li>
</ul>
<p><strong>Parallel Connection:</strong>
   - Resistors in parallel share the same voltage.</p>
<ul>
<li>
<p>The total current is the sum of the individual currents:</p>
<p>$$
 I_{eq} = I_1 + I_2 + ... + I_n
 $$</p>
</li>
<li>
<p>Using Ohm’s Law:</p>
<p>$$
 \frac{V}{R_{eq}} = \frac{V}{R_1} + \frac{V}{R_2} + ... + \frac{V}{R_n}
 $$</p>
</li>
<li>
<p>Canceling the common voltage <span class="arithmatex">\( V \)</span>:</p>
<p>$$
 \frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n}
 $$</p>
</li>
<li>
<p>Graphically, this corresponds to <strong>merging</strong> multiple edges between two nodes into a single edge with a new weight.</p>
</li>
<li>
<p>This merging reduces the computational complexity when analyzing circuits with multiple interconnected resistors.</p>
</li>
</ul>
<h3 id="extended-formulas-for-complex-cases">Extended Formulas for Complex Cases</h3>
<p>For circuits involving mixed configurations of series and parallel resistances, the equivalent resistance must be determined iteratively. If a circuit consists of nested parallel and series resistances, the calculation follows a hierarchical approach:</p>
<ul>
<li>
<p>Identify the <strong>innermost</strong> parallel or series components.</p>
</li>
<li>
<p>Compute their equivalent resistance.</p>
</li>
<li>
<p>Replace these components with their equivalent resistance and repeat the process.</p>
</li>
<li>
<p>Continue until only one resistance remains.</p>
</li>
</ul>
<p>For example, if a circuit consists of three resistors <span class="arithmatex">\( R_1, R_2, R_3 \)</span> arranged in a mixed configuration:</p>
<ul>
<li><span class="arithmatex">\( R_1 \)</span> and <span class="arithmatex">\( R_2 \)</span> in parallel:</li>
</ul>
<p>$$
  \frac{1}{R_{12}} = \frac{1}{R_1} + \frac{1}{R_2}
  $$</p>
<ul>
<li>Then, <span class="arithmatex">\( R_{12} \)</span> is in series with <span class="arithmatex">\( R_3 \)</span>:</li>
</ul>
<p>$$
  R_{eq} = R_{12} + R_3
  $$</p>
<ul>
<li>If an additional resistor <span class="arithmatex">\( R_4 \)</span> is in parallel with <span class="arithmatex">\( R_{eq} \)</span>, we apply the parallel formula again:</li>
</ul>
<p>$$
  \frac{1}{R_{final}} = \frac{1}{R_{eq}} + \frac{1}{R_4}
  $$</p>
<p>Using advanced mathematical techniques such as <strong>matrix representation of circuits</strong> and <strong>Laplace transformations</strong>, we can generalize the problem for complex networks. The impedance matrix <span class="arithmatex">\( Z \)</span> of the network can be derived using Kirchhoff’s laws and then reduced using determinant-based transformations.</p>
<h2 id="algorithmic-approach">Algorithmic Approach</h2>
<p>To find the equivalent resistance between two nodes:</p>
<p><strong>Construct the Graph</strong>: Parse circuit components into a graph data structure.</p>
<p><strong>Identify Series and Parallel Components</strong>: Use graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS).</p>
<p><strong>Iteratively Reduce the Graph</strong>:</p>
<ul>
<li>
<p>Replace series connections with their equivalent resistance.</p>
</li>
<li>
<p>Merge parallel connections into a single equivalent resistor.</p>
</li>
</ul>
<p><strong>Repeat Until Simplification is Complete</strong>: Continue reducing until only two nodes remain (input and output terminals).</p>
<p><strong>Output the Equivalent Resistance</strong>: The final edge weight represents the total equivalent resistance.</p>
<hr/>
<h2 id="algorithm-implementation">Algorithm Implementation</h2>
<h3 id="pseudocode">Pseudocode</h3>
<pre><code class="language-python">function compute_equivalent_resistance(graph, start, end):
    while graph has more than 2 nodes:
        for each node in graph:
            if node has exactly 2 neighbors (series connection):

                neighbor_1, neighbor_2 = get_neighbors(node)
                new_resistance = graph.get_edge_weight(node, neighbor_1) + graph.get_edge_weight(node, neighbor_2)
                merge_nodes(graph, node, neighbor_1, neighbor_2, new_resistance)

            elif node is part of a parallel connection:

                parallel_edges = get_parallel_edges(node)
                new_resistance = 1 / sum(1 / resistance for resistance in parallel_edges)
                merge_parallel_resistors(graph, node, new_resistance)

        if no changes were made:

            apply_advanced_reduction(graph) 

    return graph.get_edge_weight(start, end)


    RETURN the remaining resistance between start and end nodes
</code></pre>
<h3 id="implementation-plan">Implementation Plan</h3>
<p>Below is the initial representation of the circuit, modeled as a graph.<br/>
Each <strong>node (A, B, C, D)</strong> represents a connection point in the circuit,<br/>
and each <strong>edge</strong> represents a resistor with a specific resistance value.</p>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

class CircuitGraph:
    def __init__(self):
        """ Initializes an empty graph to represent the circuit. """
        self.graph = nx.Graph()

    def add_resistor(self, node1, node2, resistance):
        """ Adds a resistor between two nodes with a given resistance value. """
        self.graph.add_edge(node1, node2, weight=resistance)

    def visualize(self, title="Circuit Representation"):
        """ Visualizes the circuit graph with nodes and edge weights. """
        pos = nx.spring_layout(self.graph)  # Defines the layout of the graph
        labels = nx.get_edge_attributes(self.graph, 'weight')

        plt.figure(figsize=(8,6))
        nx.draw(self.graph, pos, with_labels=True, node_color='lightblue', edge_color='black', node_size=2000, font_size=12)
        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=labels)
        plt.title(title)
        plt.show()

# 🔹 Creating a test circuit
circuit = CircuitGraph()
circuit.add_resistor('A', 'B', 10)
circuit.add_resistor('B', 'C', 20)
circuit.add_resistor('C', 'D', 30)
circuit.add_resistor('A', 'D', 40)

# 🔹 Visualizing the initial circuit
circuit.visualize("Initial Circuit Representation")
</code></pre>
</details>
<p><img alt="alt text" src="../image-1.png"/></p>
<p><strong>Nodes (A, B, C, D):</strong> Circuit junctions.</p>
<p><strong>Edges with weights:</strong> Represent resistors with given resistance values.</p>
<p><strong>Graph Layout:</strong> The spring layout is used for better visualization.</p>
<p>This graphical representation will help us simplify the circuit in the next steps, where we will iteratively reduce the network by identifying series and parallel resistors.</p>
<h2 id="detecting-and-merging-series-and-parallel-resistors">Detecting and Merging Series and Parallel Resistors</h2>
<p>To simplify the circuit, we apply the following rules:</p>
<p><strong>Series Resistors</strong>: If a node has exactly two connections, the resistances are summed up and the node is removed.  </p>
<ul>
<li>
<p>Formula: </p>
<div class="arithmatex">\[
R_{eq} = R_1 + R_2
\]</div>
</li>
</ul>
<p><strong>Parallel Resistors</strong>: If two nodes are connected by multiple resistors, they are merged using the parallel resistance formula.  </p>
<ul>
<li>
<p>Formula:  </p>
<div class="arithmatex">\[
\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2}
\]</div>
</li>
</ul>
<p>By applying these transformations iteratively, the circuit is reduced to a simpler form.</p>
<p>After detecting and merging series and parallel resistors, the simplified circuit looks like this:</p>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">
class CircuitGraph:
    def __init__(self):
        """ Initializes an empty graph to represent the circuit. """
        self.graph = nx.Graph()

    def add_resistor(self, node1, node2, resistance):
        """ Adds a resistor between two nodes with a given resistance value. """
        self.graph.add_edge(node1, node2, weight=resistance)

    def detect_series(self):
        """ Detects and merges series resistances in the circuit """
        for node in list(self.graph.nodes):
            neighbors = list(self.graph.neighbors(node))
            if len(neighbors) == 2:  # A node with exactly two neighbors → Series connection
                n1, n2 = neighbors
                if self.graph.has_edge(n1, node) and self.graph.has_edge(node, n2):
                    r1 = self.graph[n1][node]['weight']
                    r2 = self.graph[node][n2]['weight']
                    new_resistance = r1 + r2  # Series formula: Req = R1 + R2

                    # Merge nodes
                    self.graph.add_edge(n1, n2, weight=new_resistance)
                    self.graph.remove_node(node)  # Remove merged node

    def detect_parallel(self):
        """ Detects and merges parallel resistances in the circuit """
        to_merge = []
        for u, v, data in self.graph.edges(data=True):
            if self.graph.number_of_edges(u, v) &gt; 1:  # More than one edge between nodes → Parallel
                to_merge.append((u, v))

        for u, v in to_merge:
            parallel_resistances = [
                data['weight'] for u_, v_, data in self.graph.edges(data=True) if (u_, v_) == (u, v)
            ]
            new_resistance = 1 / sum(1 / r for r in parallel_resistances)  # Parallel formula: 1/Req = 1/R1 + 1/R2

            # Remove all parallel edges and add the new equivalent resistance
            self.graph.remove_edges_from([(u, v) for _ in parallel_resistances])
            self.graph.add_edge(u, v, weight=new_resistance)

    def simplify_circuit(self):
        """ Iteratively simplifies the circuit by detecting and merging series and parallel resistances """
        while len(self.graph.nodes) &gt; 2:  # Keep simplifying until only two nodes remain
            self.detect_series()
            self.detect_parallel()

    def visualize(self, title="Circuit Representation"):
        """ Visualizes the circuit graph with nodes and edge weights. """
        pos = nx.spring_layout(self.graph)  # Defines the layout of the graph
        labels = nx.get_edge_attributes(self.graph, 'weight')

        plt.figure(figsize=(8,6))
        nx.draw(self.graph, pos, with_labels=True, node_color='lightblue', edge_color='black', node_size=2000, font_size=12)
        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=labels)
        plt.title(title)
        plt.show()


# 🔹 Creating a test circuit
circuit = CircuitGraph()
circuit.add_resistor('A', 'B', 10)
circuit.add_resistor('B', 'C', 20)
circuit.add_resistor('C', 'D', 30)
circuit.add_resistor('A', 'D', 40)

# 🔹 Visualizing the initial circuit
circuit.visualize("Initial Circuit Representation")

# 🔹 Simplifying the circuit
circuit.simplify_circuit()

# 🔹 Visualizing the simplified circuit
circuit.visualize("Simplified Circuit Representation")
</code></pre>
</details>
<p><img alt="alt text" src="../image-3.png"/></p>
<p>In this step, the circuit graph has been progressively reduced by merging equivalent resistances until only two nodes remain, representing the total equivalent resistance of the system.</p>
<h2 id="computing-the-final-equivalent-resistance">Computing the Final Equivalent Resistance</h2>
<p>After fully simplifying the circuit, only two nodes remain, representing the total equivalent resistance.</p>
<h3 id="final-equivalent-resistance-calculation"><strong>Final Equivalent Resistance Calculation</strong></h3>
<p>Using our graph-based algorithm, we obtained the following result:</p>
<p><strong>Remaining Nodes:</strong> C and D</p>
<p><strong>Final Equivalent Resistance:</strong> <strong>70Ω</strong></p>
<h3 id="final-simplified-circuit-representation"><strong>Final Simplified Circuit Representation</strong></h3>
<p>Below is the final simplified representation of the circuit:</p>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">
import networkx as nx
import matplotlib.pyplot as plt

import networkx as nx
import matplotlib.pyplot as plt

class CircuitGraph:
    def __init__(self):
        """ Initializes an empty graph to represent the circuit. """
        self.graph = nx.Graph()

    def add_resistor(self, node1, node2, resistance):
        """ Adds a resistor between two nodes.
            If a connection already exists, the new resistor is added in parallel.
        """
        if self.graph.has_edge(node1, node2):
            self.graph[node1][node2]['resistances'].append(resistance)
        else:
            self.graph.add_edge(node1, node2, resistances=[resistance])

    def detect_series(self):
        """ Detects and merges series resistances in the circuit.
            The function iterates until no more series combinations exist.
        """
        merged = True
        while merged:  # Keep looping until all series connections are merged
            merged = False
            for node in list(self.graph.nodes):
                neighbors = list(self.graph.neighbors(node))
                if len(neighbors) == 2:  # A node with exactly two neighbors → Series connection
                    n1, n2 = neighbors
                    r1 = sum(self.graph[n1][node]['resistances'])
                    r2 = sum(self.graph[node][n2]['resistances'])
                    new_resistance = r1 + r2  # Series formula: Req = R1 + R2

                    # Merge nodes
                    self.graph.add_edge(n1, n2, resistances=[new_resistance])
                    self.graph.remove_node(node)  # Remove merged node
                    merged = True
                    break  # Restart the loop since the graph structure changed

    def detect_parallel(self):
        """ Detects and merges parallel resistances in the circuit.
            It identifies parallel connections and computes their equivalent resistance.
        """
        edges = list(self.graph.edges(data=True))
        for u, v, data in edges:
            if len(data['resistances']) &gt; 1:  # Parallel connection detected
                new_resistance = 1 / sum(1/r for r in data['resistances'])  # Parallel formula
                self.graph.remove_edge(u, v)  # Remove original parallel resistors
                self.graph.add_edge(u, v, resistances=[new_resistance])  # Add equivalent resistance

    def simplify_circuit(self):
        """ Iteratively simplifies the circuit by detecting and merging parallel and series resistances.
            The process repeats until no further simplifications are possible.
        """
        prev_nodes = -1
        while len(self.graph.nodes) != prev_nodes:
            prev_nodes = len(self.graph.nodes)
            self.detect_parallel()  # First, merge parallel resistances
            self.detect_series()    # Then, merge series resistances

    def compute_equivalent_resistance(self, start, end):
        """ Computes the equivalent resistance between two nodes in the circuit.
            If the circuit was simplified correctly, this function returns the final resistance.
        """
        if self.graph.has_edge(start, end):
            return round(sum(self.graph[start][end]['resistances']), 2)  # Return total resistance
        else:
            raise ValueError("Circuit simplification failed.")  # Error if simplification was incorrect

    def visualize(self, title="Circuit Representation"):
        """ Generates a graphical visualization of the circuit.
            Nodes represent junctions, and edges represent resistors with their resistance values.
        """
        pos = nx.spring_layout(self.graph)  # Defines the graph layout
        labels = {(u, v): f"{sum(data['resistances']):.2f}Ω" for u, v, data in self.graph.edges(data=True)}

        plt.figure(figsize=(8, 6))
        nx.draw(self.graph, pos, with_labels=True, node_color='lightblue', node_size=2000)
        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=labels)
        plt.title(title)
        plt.show()


# 🔹 Creating a test circuit
circuit = CircuitGraph()
circuit.add_resistor('A', 'B', 10)
circuit.add_resistor('B', 'C', 20)
circuit.add_resistor('C', 'D', 30)
circuit.add_resistor('A', 'D', 40)

# 🔹 Visualizing the initial circuit
circuit.visualize("Initial Circuit Representation")

# 🔹 Simplifying the circuit
circuit.simplify_circuit()
print("Remaining nodes in the circuit:", circuit.graph.nodes)

# 🔹 Computing the final equivalent resistance
try:
    equivalent_resistance = circuit.compute_equivalent_resistance('C', 'D')
    print(f"Equivalent Resistance between C and D: {equivalent_resistance} Ω")
except ValueError as e:
    print(e)

# 🔹 Visualizing the final simplified circuit
circuit.visualize("Final Simplified Circuit Representation")


</code></pre>
</details>
<p><img alt="alt text" src="../image-4.png"/></p>
<p>This result confirms that all series and parallel resistances were properly merged, leading to an accurate calculation of the total equivalent resistance.</p>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python">
# Test Case 1: Simple Series Circuit
circuit1 = CircuitGraph()
circuit1.add_resistor('X', 'Y', 5)
circuit1.add_resistor('Y', 'Z', 10)
circuit1.simplify_circuit()
equivalent_resistance_1 = circuit1.compute_equivalent_resistance('X', 'Z')
print(f"Test Case 1 - Equivalent Resistance: {equivalent_resistance_1} Ω")  # Expected: 15Ω

# Test Case 2: Simple Parallel Circuit
circuit2 = CircuitGraph()
circuit2.add_resistor('M', 'N', 10)
circuit2.add_resistor('M', 'N', 20)
circuit2.simplify_circuit()
equivalent_resistance_2 = circuit2.compute_equivalent_resistance('M', 'N')
print(f"Test Case 2 - Equivalent Resistance: {equivalent_resistance_2} Ω")  # Expected: 6.67Ω

# Test Case 3: Mixed Series and Parallel
circuit3 = CircuitGraph()
circuit3.add_resistor('A', 'B', 10)
circuit3.add_resistor('B', 'C', 20)
circuit3.add_resistor('C', 'D', 30)
circuit3.add_resistor('A', 'D', 40)
circuit3.simplify_circuit()
print("Remaining nodes in the circuit after simplification:", circuit3.graph.nodes)
print("Remaining edges in the circuit after simplification:", circuit3.graph.edges(data=True))

equivalent_resistance_3 = circuit3.compute_equivalent_resistance('C', 'D')

print(f"Test Case 3 - Equivalent Resistance: {equivalent_resistance_3} Ω")  # Expected: Check Output

</code></pre>
</details>
<h2 id="performance-analysis-and-test-cases"><strong>Performance Analysis and Test Cases</strong></h2>
<h3 id="performance-analysis"><strong>Performance Analysis</strong></h3>
<p>To evaluate the efficiency of our algorithm, we analyzed the computational complexity:</p>
<p><strong>Series Detection:</strong> <span class="arithmatex">\(O(n)\)</span></p>
<p><strong>Parallel Detection:</strong> <span class="arithmatex">\(O(m)\)</span></p>
<p><strong>Overall Complexity:</strong> <span class="arithmatex">\(O(n^2)\)</span> in the worst case.</p>
<p>For large circuits, this approach is efficient but may require further optimizations in highly interconnected networks.</p>
<h3 id="test-cases-and-results"><strong>Test Cases and Results</strong></h3>
<p>To validate our implementation, we tested different circuit configurations.</p>
<h3 id="test-case-1-simple-series-circuit"><strong>Test Case 1: Simple Series Circuit</strong></h3>
<h4 id="circuit-configuration"><strong>Circuit Configuration</strong></h4>
<p><strong>Resistors:</strong> </p>
<ul>
<li>
<p>5Ω between <code>X</code> and <code>Y</code></p>
</li>
<li>
<p>10Ω between <code>Y</code> and <code>Z</code>
-Expected Result: </p>
</li>
<li>
<p>Equivalent resistance between <code>X</code> and <code>Z</code> should be <strong>15Ω</strong> (Series formula: <span class="arithmatex">\( R_{eq} = R_1 + R_2 \)</span>)</p>
</li>
</ul>
<p><img alt="alt text" src="../image-5.png"/></p>
<h3 id="test-case-2-simple-parallel-circuit"><strong>Test Case 2: Simple Parallel Circuit</strong></h3>
<h4 id="circuit-configuration_1"><strong>Circuit Configuration</strong></h4>
<p><strong>Resistors:</strong><br/>
  - 10Ω and 20Ω in parallel between <code>M</code> and <code>N</code></p>
<p><strong>Expected Result:</strong> </p>
<ul>
<li>Equivalent resistance between <code>M</code> and <code>N</code> should be <strong>6.67Ω</strong> </li>
<li>(Parallel formula: <span class="arithmatex">\( \frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} \)</span>)</li>
</ul>
<p><img alt="alt text" src="../image-9.png"/></p>
<h3 id="test-case-3-mixed-series-and-parallel-circuit"><strong>Test Case 3: Mixed Series and Parallel Circuit</strong></h3>
<h4 id="circuit-configuration_2"><strong>Circuit Configuration</strong></h4>
<p><strong>Resistors:</strong>
  - 10Ω between <code>A</code> and <code>B</code>
  - 20Ω between <code>B</code> and <code>C</code>
  - 30Ω between <code>C</code> and <code>D</code>
  - 40Ω between <code>A</code> and <code>D</code></p>
<ul>
<li>
<p><strong>Expected Result:</strong> </p>
</li>
<li>
<p>The equivalent resistance should be computed after series and parallel simplifications.</p>
</li>
</ul>
<p><img alt="alt text" src="../image-8.png"/></p>
<hr/>
<h2 id="simulation">Simulation</h2>
<p><a> file:///C:/Users/batu/Desktop/Ders/2025/PHYSICS/circuits.html</a></p>
<h2 id="final-conclusion-future-work"><strong>Final Conclusion &amp; Future Work</strong></h2>
<h3 id="conclusion"><strong>Conclusion</strong></h3>
<p>This project successfully demonstrates the application of <strong>graph theory in electrical circuit analysis</strong> to compute equivalent resistance efficiently.  </p>
<p>Instead of manually solving complex resistor networks, we developed an <strong>automated approach</strong> using graph-based algorithms.  </p>
<h3 id="key-achievements"><strong>Key Achievements:</strong></h3>
<p><strong>Mathematical Foundation:</strong> Detailed explanations of series and parallel resistances, including formulas and graphical representations.  </p>
<p><strong>Graph-Based Algorithm:</strong> Developed an iterative approach to detect and merge <strong>series and parallel connections</strong> systematically.  </p>
<p><strong>Full Python Implementation:</strong> A functional script that accepts any circuit configuration and computes its <strong>equivalent resistance</strong>.  </p>
<p><strong>Multiple Test Cases:</strong> Validation with different resistor networks, including <strong>simple, nested, and complex circuits</strong>.  </p>
<p><strong>Performance Analysis:</strong> Assessment of computational efficiency with complexity analysis.  </p>
<p><strong>Interactive Simulation:</strong> A <strong>JavaScript-based circuit simulator</strong>, allowing users to build and analyze their own circuits dynamically.</p>
<p>This work <strong>bridges theory and practical implementation</strong>, making <strong>circuit analysis more accessible, accurate, and automated</strong>.</p>
<hr/>
<h3 id="future-work"><strong>Future Work</strong></h3>
<p>Although the current implementation is robust, several enhancements can be explored:  </p>
<p><strong>Handling AC Circuits:</strong> Extend the model to support <strong>capacitors and inductors</strong>, introducing <strong>complex impedance calculations</strong>.  </p>
<p><strong>Optimized Performance for Large Circuits:</strong> Implement <strong>matrix-based</strong> methods like <strong>Laplace transforms</strong> or <strong>admittance matrices</strong> for highly interconnected circuits.  </p>
<p><strong>GUI-Based Interactive Circuit Solver:</strong> Develop a <strong>drag-and-drop</strong> interface for real-time circuit building and analysis.  </p>
<p><strong>AI-Powered Circuit Optimization:</strong> Use <strong>machine learning</strong> to suggest <strong>optimal resistor placements</strong> for minimal power loss and efficient design. </p>
<p><strong>Web-Based Deployment:</strong> Convert the simulation into a <strong>fully interactive web application</strong> with <strong>cloud storage for circuit designs</strong>.</p>
<p>This project <strong>lays the foundation for intelligent circuit analysis</strong>, with possibilities for <strong>expansion into advanced engineering applications</strong>.</p>
<hr/>
<h3 id="final-thoughts"><strong>Final Thoughts</strong></h3>
<p>Graph theory offers a <strong>powerful and scalable</strong> method for solving circuit problems.  </p>
<p>By combining <strong>theoretical knowledge with computational techniques</strong>, this project successfully automates <strong>equivalent resistance calculation</strong>, paving the way for <strong>advanced circuit analysis tools</strong>.</p>
<hr/>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
