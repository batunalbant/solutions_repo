<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 2: Estimating Pi using Monte Carlo Methods - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 2: Estimating Pi using Monte Carlo Methods";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">6 Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 2: Estimating Pi using Monte Carlo Methods</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#motivation">Motivation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#part-1-estimating-using-a-circle">Part 1: Estimating π Using a Circle</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#1-theoretical-foundation">1. Theoretical Foundation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#2-simulation">2. Simulation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#4-analysis">4. Analysis</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#part-2-estimating-using-buffons-needle">Part 2: Estimating π Using Buffon’s Needle</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#1-theoretical-foundation_1">1. Theoretical Foundation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#2-simulation_1">2. Simulation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#scatter-plot-circle-method-explanation-and-interpretation">Scatter Plot (Circle Method) - Explanation and Interpretation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#convergence-graph-circle-method-explanation-and-interpretation">Convergence Graph (Circle Method) - Explanation and Interpretation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#buffons-needle-simulation-explanation-and-interpretation">Buffon's Needle Simulation - Explanation and Interpretation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#convergence-graph-buffons-needle-method-explanation-and-interpretation">Convergence Graph (Buffon's Needle Method) - Explanation and Interpretation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-of-convergence-rates-circle-method-vs-buffons-needle-method">Comparison of Convergence Rates - Circle Method vs. Buffon's Needle Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-of-estimation-errors-circle-method-vs-buffons-needle-method">Comparison of Estimation Errors - Circle Method vs. Buffon's Needle Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#4-analysis_1">4. Analysis</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">6 Statistics</li>
<li class="breadcrumb-item active">Problem 2: Estimating Pi using Monte Carlo Methods</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-2-estimating-pi-using-monte-carlo-methods">Problem 2: Estimating Pi using Monte Carlo Methods</h1>
<h2 id="introduction">Introduction</h2>
<p>Monte Carlo methods are a class of computational algorithms that rely on random sampling to obtain numerical results. The method is particularly useful when dealing with problems that are difficult or impossible to solve analytically. One of the most famous applications of Monte Carlo methods is estimating the value of π. By employing randomness and probability, we can estimate π through simulations involving geometric probability.</p>
<p>The most common Monte Carlo approach to estimate π involves generating random points within a square and determining how many of them fall inside a circle inscribed within that square. This method, despite its simplicity, effectively demonstrates the power of random sampling in solving complex problems. Another interesting technique for estimating π is Buffon’s Needle problem, which uses probability theory to approximate π by analyzing how often a randomly dropped needle crosses parallel lines.</p>
<p>Monte Carlo methods are particularly useful because they allow for estimating values through repeated random sampling, which often provides an accurate approximation even when the exact solution is difficult to determine. As the number of samples increases, the accuracy of the approximation improves, illustrating a fundamental property of statistical convergence.</p>
<p>This problem provides insights into the fundamentals of probability, numerical computation, and statistical convergence. Through these exercises, we can better understand the efficiency and accuracy of Monte Carlo methods in approximating important mathematical constants like π. Additionally, understanding these concepts allows us to apply similar methods to a wide range of problems beyond mathematics, including physics, finance, and various fields of engineering.</p>
<hr/>
<h2 id="motivation">Motivation</h2>
<p>Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of π through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate π in an intuitive and visually engaging way.</p>
<p>This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to π estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency.</p>
<p>Furthermore, the use of Monte Carlo methods in estimating π showcases the broader applicability of these techniques, particularly in scenarios where deterministic approaches may be too complex or computationally expensive to implement. The accuracy of the approximation increases as the number of random points or needle drops increases, providing a valuable example of how statistical methods converge towards true values.</p>
<hr/>
<h2 id="part-1-estimating-using-a-circle">Part 1: Estimating π Using a Circle</h2>
<h3 id="1-theoretical-foundation">1. Theoretical Foundation</h3>
<p>The Monte Carlo method for estimating π is based on the area ratio between a circle and the square that bounds it. This method utilizes geometric probability to achieve a numerical approximation of π through random sampling.</p>
<h4 id="explanation-and-derivation">Explanation and Derivation</h4>
<p>Consider a <strong>unit circle</strong> centered at the origin <code>(0, 0)</code> and enclosed within a square of side length <code>2</code> (spanning from <code>-1</code> to <code>1</code> along both axes).</p>
<ul>
<li>The area of the square is calculated as the square of its side length:</li>
</ul>
<p>$$
  A_{square} = (2)^2 = 4
  $$</p>
<ul>
<li>
<p>The area of the circle is given by the formula for the area of a circle:
  $$
  A_{circle} = \pi r^2 = \pi (1)^2 = \pi
  $$</p>
</li>
<li>
<p>Therefore, the ratio of the area of the circle to the area of the square is: 
  $$
    \text{Ratio} = \frac{A_{circle}}{A_{square}} = \frac{\pi}{4}
  $$</p>
</li>
</ul>
<p>Now, we can use <strong>Geometric Probability</strong> to relate this ratio to a simulation:
- We randomly generate points <code>(x, y)</code> within the square with coordinates satisfying:</p>
<p>$$
  -1 \leq x \leq 1, \quad -1 \leq y \leq 1
  $$</p>
<ul>
<li>The probability that a randomly generated point falls inside the circle is equal to the ratio of the circle’s area to the square’s area.</li>
</ul>
<p>According to the probability definition:</p>
<div class="arithmatex">\[
    \text{Probability} = \frac{\text{Number of points inside circle}}{\text{Total number of points}} = \frac{\pi}{4}
\]</div>
<p>By rearranging, we can estimate <span class="arithmatex">\( \pi \)</span> as follows:</p>
<div class="arithmatex">\[
\pi \approx 4 \times \frac{\text{Number of points inside circle}}{\text{Total number of points}}
\]</div>
<h3 id="2-simulation">2. Simulation</h3>
<ol>
<li>
<p>Generate random points <code>(x, y)</code> where both <code>x</code> and <code>y</code> are uniformly distributed between <code>-1</code> and <code>1</code>.</p>
</li>
<li>
<p>Count the number of points that fall inside the unit circle by checking if:</p>
</li>
</ol>
<div class="arithmatex">\[
x^2 + y^2 \leq 1
\]</div>
<ol>
<li>Estimate π using the formula derived above.</li>
</ol>
<h3 id="4-analysis">4. Analysis</h3>
<ul>
<li>
<p>As the number of points increases, the estimate of <span class="arithmatex">\( \pi \)</span> becomes more accurate.</p>
</li>
<li>
<p>The convergence rate follows the law of large numbers and is proportional to:</p>
</li>
</ul>
<p>$$
    \text{Estimation Error} \approx \frac{1}{\sqrt{N}}
  $$</p>
<p>Where <code>N</code> is the total number of random points.</p>
<hr/>
<h2 id="part-2-estimating-using-buffons-needle">Part 2: Estimating π Using Buffon’s Needle</h2>
<h3 id="1-theoretical-foundation_1">1. Theoretical Foundation</h3>
<p>Buffon’s Needle problem is a classic Monte Carlo simulation used to estimate <span class="arithmatex">\( \pi \)</span> based on probability.</p>
<h4 id="description-and-derivation">Description and Derivation</h4>
<p>Consider a floor with equally spaced parallel lines separated by a distance <code>d</code>. A needle of length <code>L</code> is randomly dropped onto this plane. We want to determine the probability that the needle crosses one of the lines.</p>
<p>If <span class="arithmatex">\( L \leq d \)</span>, the probability of crossing a line depends on two random variables:</p>
<p><strong>θ:</strong> The acute angle between the needle and the parallel lines, which is uniformly distributed between <span class="arithmatex">\( 0 \)</span> and <span class="arithmatex">\(\frac{\pi}{2}\)</span></p>
<p><strong>x:</strong> The distance from the midpoint of the needle to the nearest line, uniformly distributed between <span class="arithmatex">\( 0 \)</span> and <span class="arithmatex">\(\frac{d}{2}\)</span>.</p>
<p>The needle crosses the line if:</p>
<div class="arithmatex">\[
x \leq \frac{L}{2} \sin(\theta)
\]</div>
<p>Calculating the probability involves integrating over all possible values of <span class="arithmatex">\(     heta \)</span>:</p>
<div class="arithmatex">\[
P = \frac{2}{\pi} \int_{0}^{\frac{\pi}{2}} \frac{L}{d} \sin(\theta) d\theta = \frac{2L}{\pi d}
\]</div>
<p>Rearranging to solve for <span class="arithmatex">\( \pi \)</span>:</p>
<div class="arithmatex">\[
\pi \approx \frac{2L}{dP}
\]</div>
<h3 id="2-simulation_1">2. Simulation</h3>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python"># Plotting the Scatter Plot (Circle Method) again with clearer styling for presentation

plt.figure(figsize=(6, 6))
plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle')
plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle')
plt.title('Random Points Distribution - Estimating Pi (Circle Method)')
plt.xlabel('X')
plt.ylabel('Y')
plt.axis('equal')
plt.legend()
plt.grid(True)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-5.png"/></p>
<h3 id="scatter-plot-circle-method-explanation-and-interpretation">Scatter Plot (Circle Method) - Explanation and Interpretation</h3>
<h4 id="what-this-graph-represents">What This Graph Represents:</h4>
<p>The graph shows the randomly generated points used to estimate the value of <span class="arithmatex">\( \pi \)</span> through the Monte Carlo Method. This method compares the number of points that fall inside a unit circle to the total number of points generated within a bounding square.</p>
<hr/>
<h4 id="key-points-to-understand">Key Points to Understand:</h4>
<ol>
<li>
<p><strong>Square and Circle Definition:</strong> </p>
</li>
<li>
<p>The <strong>square</strong> has its sides ranging from <span class="arithmatex">\( -1 \)</span> to <span class="arithmatex">\( 1 \)</span> along both the <span class="arithmatex">\( x \)</span>-axis and <span class="arithmatex">\( y \)</span>-axis.</p>
</li>
<li>
<p>The <strong>circle</strong> is a unit circle centered at the origin <span class="arithmatex">\((0,0)\)</span> with a radius of <span class="arithmatex">\( r = 1 \)</span>.</p>
</li>
</ol>
<p><strong>Point Classification:</strong> </p>
<ul>
<li>
<p><strong>Blue Points (Inside Circle):</strong> Points satisfying the condition:</p>
<p>$$
 x^2 + y^2 \leq 1
 $$</p>
</li>
<li>
<p><strong>Red Points (Outside Circle):</strong> Points that do not satisfy the above condition.</p>
</li>
</ul>
<p><strong>Mathematical Basis for Estimation:</strong> </p>
<ul>
<li>
<p>The area of the square is calculated by:</p>
<p>$$
 A_{\text{square}} = (2)^2 = 4
 $$</p>
</li>
<li>
<p>The area of the circle is given by:</p>
</li>
</ul>
<p>$$
     A_{\text{circle}} = \pi r^2 = \pi (1)^2 = \pi
   $$</p>
<ul>
<li>
<p>The ratio of the area of the circle to the area of the square is:</p>
<p>$$
 \text{Ratio} = \frac{A_{\text{circle}}}{A_{\text{square}}} = \frac{\pi}{4}
 $$</p>
</li>
</ul>
<p><strong>Estimation Formula:</strong> </p>
<ul>
<li>
<p>Using the ratio derived above, the probability of a randomly generated point falling inside the circle is:</p>
<p>$$
 \text{Probability} = \frac{\text{Number of points inside circle}}{\text{Total number of points}} = \frac{\pi}{4}
 $$</p>
</li>
<li>
<p>Rearranging the formula to solve for <span class="arithmatex">\( \pi \)</span>:</p>
<p>$$
 \pi \approx 4 \times \frac{\text{Number of points inside the circle}}{\text{Total number of points}}
 $$</p>
</li>
</ul>
<hr/>
<h4 id="interpretation-of-the-graph">Interpretation of the Graph:</h4>
<ul>
<li>
<p>As shown in the graph, the <strong>blue points</strong> are those that lie within the circular region, while the <strong>red points</strong> are those outside the circle but within the square.</p>
</li>
<li>
<p>The approximation of <span class="arithmatex">\( \pi \)</span> is based on the ratio of blue points to the total points.</p>
</li>
<li>
<p>The more points we generate, the closer our estimate of <span class="arithmatex">\( \pi \)</span> will be to the actual value <span class="arithmatex">\( \approx 3.14159 \)</span>.</p>
</li>
<li>
<p>This method demonstrates how randomness can be harnessed to make accurate estimations through probability.</p>
</li>
</ul>
<details>
<summary>Phyton codes.</summary>

---


<pre><code class="language-python"># Generating data for the Convergence Graph (Circle Method)
max_points = 100000  # Maximum number of points to generate
step_size = 1000     # Step size for increasing the number of points

# Function to estimate Pi over multiple iterations for the Convergence Graph
def estimate_pi_convergence(max_points, step_size):
    """
    Estimate Pi over multiple iterations and store the results for plotting a convergence graph.

    Args:
        max_points (int): The maximum number of points to generate.
        step_size (int): The step size for generating points (e.g., 100, 1000).

    Returns:
        list: A list of point counts.
        list: A list of corresponding Pi estimates.
    """
    points_counts = []
    pi_estimates = []

    for num_points in range(step_size, max_points + 1, step_size):
        pi_estimate, _, _, _ = estimate_pi_circle(num_points)
        points_counts.append(num_points)
        pi_estimates.append(pi_estimate)

    return points_counts, pi_estimates

# Generate convergence data
points_counts, pi_estimates = estimate_pi_convergence(max_points, step_size)

# Plotting the Convergence Graph
plt.figure(figsize=(10, 6))
plt.plot(points_counts, pi_estimates, color='blue', label='Estimated Pi Value')
plt.axhline(y=np.pi, color='red', linestyle='--', label='True Pi Value (3.14159...)')
plt.title('Convergence of Pi Estimation with Increasing Number of Points')
plt.xlabel('Number of Points (N)')
plt.ylabel('Estimated Pi Value')
plt.legend()
plt.grid(True)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-6.png"/></p>
<h3 id="convergence-graph-circle-method-explanation-and-interpretation">Convergence Graph (Circle Method) - Explanation and Interpretation</h3>
<h4 id="what-this-graph-represents_1">What This Graph Represents:</h4>
<p>The graph illustrates how the estimated value of <span class="arithmatex">\( \pi \)</span> changes as the number of randomly generated points (<span class="arithmatex">\( N \)</span>) increases. This graph visually demonstrates the <strong>convergence property of the Monte Carlo Method</strong>.</p>
<hr/>
<h4 id="key-points-to-understand_1">Key Points to Understand:</h4>
<p><strong>True Pi Value (Red Dashed Line):</strong> </p>
<ul>
<li>
<p>The horizontal red dashed line indicates the true value of <span class="arithmatex">\( \pi \)</span> which is approximately:</p>
<p>$$
 \pi \approx 3.14159
 $$</p>
</li>
<li>
<p>This serves as a reference to evaluate how well the estimation process is performing.</p>
</li>
</ul>
<p><strong>Estimated Pi Value (Blue Line):</strong> </p>
<ul>
<li>
<p>The blue line represents the estimated value of <span class="arithmatex">\( \pi \)</span> as the number of points increases.</p>
</li>
<li>
<p>There is significant fluctuation at the beginning, but as the number of points increases, the estimate approaches the true value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
</ul>
<p><strong>Law of Large Numbers:</strong> </p>
<ul>
<li>
<p>According to statistical theory, the <strong>Estimation Error</strong> decreases proportionally to the inverse of the square root of the number of points <span class="arithmatex">\( N \)</span>:</p>
<p>$$
 \text{Estimation Error} \approx \frac{1}{\sqrt{N}}
 $$</p>
</li>
<li>
<p>This explains why the fluctuations decrease as <span class="arithmatex">\( N \)</span> increases, resulting in a more accurate estimation.</p>
</li>
</ul>
<p><strong>Interpretation of the Graph:</strong> </p>
<ul>
<li>
<p>At smaller values of <span class="arithmatex">\( N \)</span>, the estimate of <span class="arithmatex">\( \pi \)</span> is unstable and may differ significantly from the true value.</p>
</li>
<li>
<p>As <span class="arithmatex">\( N \)</span> increases, the estimate becomes more consistent and approaches the true value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
<li>
<p>The method provides a clear visualization of how randomness and probability can be harnessed to make accurate estimations over time.</p>
</li>
</ul>
<hr/>
<h4 id="purpose-of-the-graph">Purpose of the Graph:</h4>
<ul>
<li>
<p>To demonstrate how the <strong>Monte Carlo Method's accuracy improves with more sampling points</strong>.</p>
</li>
<li>
<p>To visualize the convergence behavior of the estimated value of <span class="arithmatex">\( \pi \)</span> towards the actual value.</p>
</li>
</ul>
<hr/>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python"># Importing required libraries
import numpy as np
import matplotlib.pyplot as plt

# Function to simulate Buffon's Needle Method

def buffons_needle_simulation(num_needles, L, d):
    """
    Simulate Buffon's Needle problem to estimate Pi.

    Args:
        num_needles (int): The number of needles to drop.
        L (float): Length of the needle.
        d (float): Distance between parallel lines.

    Returns:
        float: Estimated value of Pi.
        np.array: X-coordinates of the needle midpoints.
        np.array: Angles of the needles.
        np.array: Boolean array indicating whether each needle crosses a line.
    """
    # Generate random midpoints and angles
    x_midpoints = np.random.uniform(0, d / 2, num_needles)
    angles = np.random.uniform(0, np.pi / 2, num_needles)

    # Check if the needle crosses a line
    crosses_line = x_midpoints &lt;= (L / 2) * np.sin(angles)

    # Count the number of crossings
    num_crosses = np.sum(crosses_line)

    # Estimate Pi using the formula
    pi_estimate = (2 * L * num_needles) / (d * num_crosses) if num_crosses &gt; 0 else np.inf

    return pi_estimate, x_midpoints, angles, crosses_line


# Simulation parameters
num_needles = 1000
L = 1.0
d = 2.0

# Perform the simulation
pi_estimate, x_midpoints, angles, crosses_line = buffons_needle_simulation(num_needles, L, d)

# Plotting the needles
plt.figure(figsize=(10, 6))
for i in range(num_needles):
    x0 = x_midpoints[i]
    y0 = np.random.uniform(0, 10)  # Random position on the plane
    x1 = x0 + (L / 2) * np.cos(angles[i])
    x2 = x0 - (L / 2) * np.cos(angles[i])

    if crosses_line[i]:
        plt.plot([x1, x2], [y0, y0], color='red')  # Crossed needles
    else:
        plt.plot([x1, x2], [y0, y0], color='blue')  # Non-crossed needles

# Drawing parallel lines
for i in range(0, 10):
    plt.axvline(x=i * d / 2, color='black', linestyle='--')

plt.title(f"Buffon's Needle Simulation - Estimated Pi: {pi_estimate}")
plt.xlabel("X Position")
plt.ylabel("Y Position")
plt.xlim(0, d * 5)
plt.ylim(0, 10)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-7.png"/></p>
<h3 id="buffons-needle-simulation-explanation-and-interpretation">Buffon's Needle Simulation - Explanation and Interpretation</h3>
<h4 id="what-this-graph-represents_2">What This Graph Represents:</h4>
<p>The graph above displays the simulation of <strong>Buffon's Needle Problem</strong>, where randomly dropped needles are used to estimate the value of <span class="arithmatex">\( \pi \)</span> based on probability theory.</p>
<hr/>
<h4 id="key-points-to-understand_2">Key Points to Understand:</h4>
<p><strong>Parallel Lines:</strong> </p>
<ul>
<li>
<p>The parallel lines are represented by the <strong>black dashed lines</strong>, spaced equally apart by a distance <span class="arithmatex">\( d = 2 \)</span>.</p>
</li>
<li>
<p>The lines are evenly spaced along the <span class="arithmatex">\( x \)</span>-axis.</p>
</li>
</ul>
<p><strong>Needle Drops:</strong> </p>
<ul>
<li>
<p>The <strong>blue lines</strong> represent needles that <strong>do not cross any line</strong>.</p>
</li>
<li>
<p>The <strong>red lines</strong> represent needles that <strong>cross at least one line</strong>.</p>
</li>
<li>
<p>Each needle is generated with a random midpoint position and a random angle between <span class="arithmatex">\( 0 \)</span> and <span class="arithmatex">\( \frac{\pi}{2} \)</span>.</p>
</li>
</ul>
<p><strong>Mathematical Basis for Estimation:</strong> </p>
<ul>
<li>
<p>The probability of a needle crossing a line is given by:</p>
<p>$$
 P = \frac{2L}{\pi d}
 $$</p>
</li>
<li>
<p>Where:</p>
<ul>
<li>
<p><span class="arithmatex">\( L \)</span>: Length of the needle.</p>
</li>
<li>
<p><span class="arithmatex">\( d \)</span>: Distance between the parallel lines.</p>
</li>
</ul>
</li>
<li>
<p>Rearranging to estimate <span class="arithmatex">\( \pi \)</span>:</p>
<p>$$
 \pi \approx \frac{2L \times \text{Number of Needles}}{d \times \text{Number of Crossings}}
 $$</p>
</li>
</ul>
<p><strong>Interpretation of the Graph:</strong> </p>
<ul>
<li>
<p>This graph visually shows how the needles interact with the parallel lines.</p>
</li>
<li>
<p>The estimated value of <span class="arithmatex">\( \pi \)</span> is calculated based on the ratio of crossed needles to the total number of needles.</p>
</li>
<li>
<p>More needles produce a more accurate estimation of <span class="arithmatex">\( \pi \)</span>.
<strong>Estimation Result:</strong> </p>
</li>
<li>
<p>The estimated value of <span class="arithmatex">\( \pi \)</span> from this simulation: <strong>3.24675</strong> (Not very accurate, more needles required for better estimation).</p>
</li>
</ul>
<hr/>
<h4 id="purpose-of-the-graph_1">Purpose of the Graph:</h4>
<ul>
<li>
<p>To demonstrate how randomness and probability can be used to estimate <span class="arithmatex">\( \pi \)</span>.</p>
</li>
<li>
<p>To visualize the crossing condition of needles with the parallel lines and how it contributes to the estimation process.</p>
</li>
<li>
<p>Check if the needle crosses a line based on its midpoint and orientation.</p>
</li>
<li>
<p>Repeat for many iterations to calculate the probability.</p>
</li>
<li>
<p>Estimate <span class="arithmatex">\( \pi \)</span> using the derived formula.</p>
</li>
</ul>
<hr/>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python"># Function to estimate Pi using Buffon's Needle Method over multiple iterations
def buffons_needle_convergence(max_needles, step_size, L, d):
    """
    Estimate Pi using Buffon's Needle method over multiple iterations and store the results for plotting a convergence graph.

    Args:
        max_needles (int): The maximum number of needles to drop.
        step_size (int): The step size for increasing the number of needles.
        L (float): Length of the needle.
        d (float): Distance between parallel lines.

    Returns:
        list: A list of needle counts.
        list: A list of corresponding Pi estimates.
    """
    needles_counts = []
    pi_estimates = []

    for num_needles in range(step_size, max_needles + 1, step_size):
        pi_estimate, _, _, _ = buffons_needle_simulation(num_needles, L, d)
        needles_counts.append(num_needles)
        pi_estimates.append(pi_estimate)

    return needles_counts, pi_estimates

# Generate data for the convergence graph
max_needles = 100000
step_size = 1000
needles_counts, pi_estimates = buffons_needle_convergence(max_needles, step_size, L, d)

# Plotting the Convergence Graph (Buffon's Needle Method)
plt.figure(figsize=(10, 6))
plt.plot(needles_counts, pi_estimates, color='blue', label="Estimated Pi Value")
plt.axhline(y=np.pi, color='red', linestyle='--', label='True Pi Value (3.14159...)')
plt.title("Convergence of Pi Estimation (Buffon's Needle Method)")
plt.xlabel("Number of Needles (N)")
plt.ylabel("Estimated Pi Value")
plt.legend()
plt.grid(True)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-8.png"/></p>
<h3 id="convergence-graph-buffons-needle-method-explanation-and-interpretation">Convergence Graph (Buffon's Needle Method) - Explanation and Interpretation</h3>
<h4 id="what-this-graph-represents_3">What This Graph Represents:</h4>
<p>This graph illustrates how the estimated value of <span class="arithmatex">\( \pi \)</span> changes as the number of randomly dropped needles (<span class="arithmatex">\( N \)</span>) increases. The purpose is to visualize the convergence of the estimated <span class="arithmatex">\( \pi \)</span> value towards the true value of <span class="arithmatex">\( \pi \)</span> as more samples are used in the simulation.</p>
<hr/>
<h4 id="key-points-to-understand_3">Key Points to Understand:</h4>
<p><strong>True Pi Value (Red Dashed Line):</strong> </p>
<ul>
<li>
<p>The horizontal red dashed line indicates the true value of <span class="arithmatex">\( \pi \)</span> which is approximately:</p>
<p><span class="arithmatex">\(
 pi \approx 3.14159
 \)</span></p>
</li>
<li>
<p>It serves as a reference for evaluating the accuracy of the simulation.</p>
</li>
</ul>
<p><strong>Estimated Pi Value (Blue Line):</strong> </p>
<ul>
<li>
<p>The blue line shows the estimated value of <span class="arithmatex">\( \pi \)</span> calculated from the Buffon's Needle simulation as the number of needles increases.</p>
</li>
<li>
<p>At smaller values of <span class="arithmatex">\( N \)</span>, the estimate fluctuates significantly.</p>
</li>
<li>
<p>As <span class="arithmatex">\( N \)</span> increases, the estimate approaches the true value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
</ul>
<p><strong>Mathematical Basis for Estimation:</strong> </p>
<ul>
<li>
<p>The probability of a needle crossing a line is:</p>
<p><span class="arithmatex">\(
 P = \frac{2L}{\pi d}
\)</span></p>
</li>
<li>
<p>Therefore, the estimated value of <span class="arithmatex">\( \pi \)</span> is:</p>
<p>$$
 \pi \approx \frac{2L \times \text{Number of Needles}}{d \times \text{Number of Crossings}}
 $$</p>
</li>
<li>
<p>Where:</p>
<ul>
<li>
<p><span class="arithmatex">\( L \)</span>: Length of the needle.</p>
</li>
<li>
<p><span class="arithmatex">\( d \)</span>: Distance between the parallel lines.</p>
</li>
<li>
<p>Number of Crossings: The number of needles that intersect with the parallel lines.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Convergence Principle:</strong> </p>
<ul>
<li>
<p>According to statistical theory, the estimation error decreases as the number of samples increases.</p>
</li>
<li>
<p>The fluctuation decreases over time, resulting in more accurate approximations of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
</ul>
<hr/>
<h4 id="purpose-of-the-graph_2">Purpose of the Graph:</h4>
<ul>
<li>
<p>To demonstrate how increasing the number of needles used in the simulation improves the accuracy of the estimated value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
<li>
<p>To visualize the random fluctuation and convergence behavior of the Monte Carlo Method applied to Buffon's Needle problem.</p>
</li>
</ul>
<details>
<summary>Phyton codes.</summary>

---


<pre><code class="language-python"># Generating data for Circle Method Convergence (Again for Comparison)
circle_points_counts, circle_pi_estimates = estimate_pi_convergence(max_points, step_size)

# Plotting the Comparison Graph
plt.figure(figsize=(12, 6))
plt.plot(circle_points_counts, circle_pi_estimates, color='green', label="Circle Method - Estimated Pi")
plt.plot(needles_counts, pi_estimates, color='blue', label="Buffon's Needle Method - Estimated Pi")
plt.axhline(y=np.pi, color='red', linestyle='--', label='True Pi Value (3.14159...)')
plt.title("Comparison of Convergence Rates - Circle Method vs. Buffon's Needle Method")
plt.xlabel("Number of Samples (N)")
plt.ylabel("Estimated Pi Value")
plt.legend()
plt.grid(True)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-9.png"/></p>
<h3 id="comparison-of-convergence-rates-circle-method-vs-buffons-needle-method">Comparison of Convergence Rates - Circle Method vs. Buffon's Needle Method</h3>
<h4 id="what-this-graph-represents_4">What This Graph Represents:</h4>
<p>The graph compares the convergence behavior of two different Monte Carlo methods for estimating <span class="arithmatex">\( \pi \)</span>:</p>
<p><strong>Circle Method (Green Line):</strong> </p>
<ul>
<li>
<p>Uses randomly generated points within a square and counts how many fall inside an inscribed circle.</p>
</li>
<li>
<p>Formula for estimation:</p>
<p>$$
 \pi \approx 4 \times \frac{\text{Number of points inside circle}}{\text{Total number of points}}
 $$</p>
</li>
</ul>
<p><strong>Buffon's Needle Method (Blue Line):</strong> </p>
<ul>
<li>
<p>Uses randomly dropped needles on a plane with parallel lines.</p>
</li>
<li>
<p>Estimates <span class="arithmatex">\( \pi \)</span> based on the probability of a needle crossing a line.</p>
</li>
<li>
<p>Formula for estimation:</p>
<p>$$
 \pi \approx \frac{2L \times \text{Number of Needles}}{d \times \text{Number of Crossings}}
 $$</p>
</li>
</ul>
<hr/>
<h4 id="key-observations">Key Observations:</h4>
<ul>
<li>
<p>The <strong>red dashed line</strong> represents the true value of <span class="arithmatex">\( \pi \)</span> (<span class="arithmatex">\( \approx 3.14159 \)</span>).</p>
</li>
<li>
<p>The <strong>Circle Method (Green Line)</strong>:</p>
</li>
<li>
<p>Exhibits smaller fluctuations and more consistent convergence towards the true value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
<li>
<p>Shows higher accuracy and stability compared to Buffon's Needle Method.</p>
</li>
<li>
<p>The <strong>Buffon's Needle Method (Blue Line)</strong>:</p>
</li>
<li>
<p>Shows larger fluctuations and slower convergence, especially for smaller sample sizes.</p>
</li>
<li>
<p>The noise in the data is higher because this method relies on a probability-based crossing condition which requires more samples for accuracy.</p>
</li>
</ul>
<hr/>
<h4 id="why-this-graph-is-important">Why This Graph is Important:</h4>
<ul>
<li>
<p>This comparison highlights the <strong>difference in convergence rates</strong> and <strong>accuracy</strong> between two Monte Carlo-based methods for estimating <span class="arithmatex">\( \pi \)</span>.</p>
</li>
<li>
<p>It also demonstrates how the <strong>Circle Method is much more efficient</strong> than Buffon's Needle Method, particularly for a smaller number of samples.</p>
</li>
</ul>
<hr/>
<h4 id="conclusion">Conclusion:</h4>
<ul>
<li>
<p>The Circle Method provides a faster and more reliable estimation of <span class="arithmatex">\( \pi \)</span> due to its direct geometric approach.</p>
</li>
<li>
<p>Buffon's Needle Method, while interesting from a probabilistic standpoint, requires significantly more samples to achieve similar accuracy.</p>
</li>
</ul>
<hr/>
<details>
<summary>Phyton codes.</summary>
<pre><code class="language-python"># Function to calculate estimation errors for both methods
def calculate_errors(true_value, estimates):
    """
    Calculate the absolute errors for a list of estimated values compared to the true value.

    Args:
        true_value (float): The true value of Pi to compare against.
        estimates (list): A list of estimated Pi values.

    Returns:
        list: A list of absolute errors.
    """
    return [abs(true_value - estimate) for estimate in estimates]

# Calculating errors for both methods
true_pi = np.pi
circle_errors = calculate_errors(true_pi, circle_pi_estimates)
buffon_errors = calculate_errors(true_pi, pi_estimates)

# Plotting the Comparison of Estimation Errors
plt.figure(figsize=(12, 6))
plt.plot(circle_points_counts, circle_errors, color='green', label="Circle Method - Estimation Error")
plt.plot(needles_counts, buffon_errors, color='blue', label="Buffon's Needle Method - Estimation Error")
plt.title("Comparison of Estimation Errors - Circle Method vs. Buffon's Needle Method")
plt.xlabel("Number of Samples (N)")
plt.ylabel("Estimation Error")
plt.yscale('log')  # Using logarithmic scale for better visualization of errors
plt.legend()
plt.grid(True)
plt.show()

</code></pre>
</details>
<p><img alt="alt text" src="../image-10.png"/></p>
<h3 id="comparison-of-estimation-errors-circle-method-vs-buffons-needle-method">Comparison of Estimation Errors - Circle Method vs. Buffon's Needle Method</h3>
<h4 id="what-this-graph-represents_5">What This Graph Represents:</h4>
<p>This graph compares the <strong>Estimation Errors</strong> of two different Monte Carlo methods for estimating <span class="arithmatex">\( \pi \)</span> as the number of samples (<span class="arithmatex">\( N \)</span>) increases. The comparison shows how efficiently each method converges to the true value of <span class="arithmatex">\( \pi \)</span>.</p>
<hr/>
<h4 id="key-points-to-understand_4">Key Points to Understand:</h4>
<p><strong>Circle Method (Green Line):</strong> </p>
<ul>
<li>
<p>The estimation error is calculated as the absolute difference between the estimated value and the true value of <span class="arithmatex">\( \pi \)</span>:</p>
<p>$$
 \text{Error} = \left| \pi_{\text{True}} - \pi_{\text{Estimated}} \right|
 $$</p>
</li>
<li>
<p>The Circle Method demonstrates a much lower error rate across all sample sizes.</p>
</li>
<li>
<p>Converges quickly and stabilizes around the true value of <span class="arithmatex">\( \pi \)</span>.</p>
</li>
</ul>
<p><strong>Buffon's Needle Method (Blue Line):</strong> </p>
<ul>
<li>
<p>The estimation error for this method is also calculated using the same formula:</p>
<p>$$
 \text{Error} = \left| \pi_{\text{True}} - \pi_{\text{Estimated}} \right|
 $$</p>
</li>
<li>
<p>Exhibits larger fluctuations, especially at smaller sample sizes.</p>
</li>
<li>
<p>The error rate decreases much slower compared to the Circle Method.</p>
</li>
</ul>
<p><strong>Logarithmic Scale:</strong> </p>
<ul>
<li>
<p>The <span class="arithmatex">\( y \)</span>-axis is represented on a logarithmic scale to clearly show differences in error magnitudes.</p>
</li>
<li>
<p>This scale helps visualize the higher accuracy of the Circle Method compared to Buffon's Needle Method.</p>
</li>
</ul>
<hr/>
<h4 id="why-this-graph-is-important_1">Why This Graph is Important:</h4>
<ul>
<li>
<p>It clearly shows the efficiency difference between <strong>Circle Method and Buffon's Needle Method</strong> in terms of estimation error.</p>
</li>
<li>
<p>The Circle Method is consistently more accurate, requiring far fewer samples to achieve low error values.</p>
</li>
<li>
<p>Buffon's Needle Method requires significantly more samples to achieve similar accuracy.</p>
</li>
</ul>
<hr/>
<h4 id="conclusion_1">Conclusion:</h4>
<ul>
<li>
<p>The Circle Method is superior in terms of efficiency, accuracy, and convergence speed.</p>
</li>
<li>
<p>Buffon's Needle Method, although interesting, is not practical for high-accuracy estimations of <span class="arithmatex">\( \pi \)</span> unless an extremely large number of samples is used.</p>
</li>
</ul>
<h3 id="4-analysis_1">4. Analysis</h3>
<ul>
<li>
<p>As the number of needle drops increases, the estimate of <span class="arithmatex">\( \pi \)</span> becomes more accurate.</p>
</li>
<li>
<p>The convergence rate is slower compared to the circle-based Monte Carlo method, making it less efficient for practical computation.</p>
</li>
</ul>
<hr/>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
